# 一、结构体定义

Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。Go语言的结构体有点像面向对象语言中的“类”。

结构体定义需要使用 type 和 struct 语句。

- struct 语句定义一个新的数据类型，结构体中有一个或多个成员。
- type 语句设定了结构体的名称。

使用结构体的时候需要注意的点：

- 定义的结构体如果只在当前包内使用，结构体的属性不用区分大小写。

- 如果想要被其他的包引用，那么结构体的属性的首字母需要大写。

```go
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}
```

一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：

```go
variable_name := structure_variable_type {value1, value2...valuen}
或
variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}
```

```go
package main

import "fmt"

type Books struct {
	title  string
	author string
	bookno int
}

func main() {
	// 方式一，按顺序赋值
	var bookA = Books{"C语言程序设计", "小明", 10010}
	// 方式二，使用 key => value 格式赋值
	var bookB = Books{bookno: 10020, title: "Go 语言开发"}
	// 方式三，单独赋值
	var bookC Books
	bookC.title = "数据结构"
	bookC.author = "小红"

	// 打印
	fmt.Printf("bookA: %v\n", bookA)
	fmt.Printf("bookB: %v\n", bookB)
	// 单独访问成员，没赋值的成员为 0 或 空
	fmt.Printf("bookA.author: %v\n", bookA.author)
	fmt.Printf("bookB.author: %v\n", bookB.author)
	fmt.Printf("bookC.bookno: %v\n", bookC.bookno)
}
```

运行结果：

```go
bookA: {C语言程序设计 小明 10010}
bookB: {Go 语言开发  10020}
bookA.author: 小明
bookB.author: 
bookC.bookno: 0
```

# 二、结构体作为函数参数

```go
package main

import "fmt"

type Books struct {
	title  string
	author string
	bookno int
}

// 定义函数，入参为 Books 类型的结构体
func printBook(book Books) {
	fmt.Println(book)
}

func main() {
	bookA := Books{"C语言程序设计", "小明", 10010}
	printBook(bookA)
}
```

运行结果

```go
{C语言程序设计 小明 10010}
```

# 三、结构体指针

如果想在函数里面改变结果体数据内容，需要传入指针，可以定义指向结构体的指针，格式如下：

```go
var struct_pointer *Books
```

```go
package main

import "fmt"

type Books struct {
	title  string
	author string
	bookno int
}

// 定义函数，入参为 *Books 指针类型
func modifyBookAuthor(book *Books, newAuther string) {
	book.author = newAuther
}

func main() {
	bookA := Books{"C语言程序设计", "小明", 10010}
	modifyBookAuthor(&bookA, "小红")
	fmt.Printf("bookA: %v\n", bookA)
}
```

运行结果：

```go
bookA: {C语言程序设计 小红 10010}
```

# 四、结构体方法

为结构体添加方法，需要单独写一个方法函数：

```go
package main

import "fmt"

type Books struct {
	title  string
	author string
	bookno int
}

func (book *Books) introduce() string {
	// 调用成员变量可以使用 变量名.成员名、指针名.成员名 都可以，相当于自动解引用。
	var name = book.title
	return "你好，我是:" + name
}

func main() {
	bookA := Books{"C 语言程序设计", "小明", 10010}
	bookB := Books{"Go 语言开发", "小红", 10020}
	// 谁实例化，则谁拥有该方法，
	fmt.Printf("bookA.introduce(): %v\n", bookA.introduce())
	fmt.Printf("bookB.introduce(): %v\n", bookB.introduce())
}
```

运行结果

```go
bookA.introduce(): 你好，我是:C 语言程序设计
bookB.introduce(): 你好，我是:Go 语言开发
```

# 五、匿名结构体

匿名结构体：标识符直接使用 struct 部分结构体本身来作为类型，而不是使用 type 定义的有名字的结构体的标识符。

可以使用 `var`、`const`、`:=`来定义匿名结构体。

type 定义结构体的标识符，可以反复定义其结构体实例，但是匿名结构体是一次性的。

匿名结构体，只是为了快速方便地得到一个结构体实例，而不是使用结构体创建N个实例。

```go
package main

import "fmt"

func main() {
	// 常规声明定义
	type Phone struct {
		id   int
		name string
	}

	// 匿名结构体声明
	var Nokia struct {
		price int
		name  string
	}

	// 匿名结构体，声明并且初始化
	var IPhone = struct {
		price int
		name  string
	}{1999, "苹果手机"}

	fmt.Println(Phone{})
	fmt.Println(Nokia)
	fmt.Println(IPhone)
}
```

```go
{0 }
{0 }
{1999 苹果手机}
```

## 5.1 匿名成员

结构体的属性名可以省略（不建议）

```go
package main

import "fmt"

func main() {
	type Point struct {
		x    int
		int  // 字段，匿名成员变量
		bool // 匿名，必须类型不一样才能区分
	}
	var p1 = Point{1, 2, false}
	fmt.Println(p1)
	var p2 = Point{x: 20, int: 5, bool: false} // 使用类型名作为字段名
	fmt.Println(p2)
	fmt.Println(p1.x, p2.int, p2.bool)
}
```

# 七、面向对象

面向对象三要素：

- 封装：将属性（数据）和方法（操作）封装，提供访问控制，隐藏实现细节，暴露该暴露的
- 继承：子类可以从父类直接获得属性和方法，减少重复定义。子类中如果与父类不同，可以自己定 义新的属性和方法，也可以覆盖同名的属性和方法
- 多态：前提是继承和覆盖，使得子类中虽然使用同一个方法，但是不同子类表现不同，就是不同的态

实现了以上特征的语言，才能成为面向对象编程范式语言。

## 7.1 封装

**构造函数**：Go 语言并没有从语言层面为结构体提供什么构造器，但是有时候可以通过一个函数为结构体初始化提供属性值，从而方便得到一个结构体实例。

习惯上，函数命名为 NewXxx 的形式。如果有多个构造函数，可以使用不同命名函数，因为 Go 也没有函数重载。

```go
package main

import "fmt"

type Phone struct {
	price int
	name  string
}

// 习惯上返回值会采用指针类型，减少值拷贝，减少内存开销
func NewPhone(price int, name string) *Phone {
	phone := Phone{price, name}
	return &phone
}

func main() {
	Nokia := NewPhone(580, "Nokia")
	fmt.Println(*Nokia)
}
```

运行结果

```go
{580 Nokia}
```

## 7.2 继承

**父子关系构造：**子结构体可以直接继承父结构体的属性并使用。使用结构体嵌套实现类似面向对象父类子类继承（派生）的效果。子结构体使用匿名成员能简化调用父结构体成员。

```go
package main

import (
	"fmt"
)

// 父结构体
type Phone struct {
	price int
	name  string
}

// 父结构体方法
func (P *Phone) act() {
	fmt.Println(P.name, "打电话")
}

// 子结构体
type Nokia struct {
	Phone
	color string
}

func main() {
	lumia := new(Nokia) // 实例化
	lumia.color = "黑色"
	lumia.Phone.name = "露米娅" // 完整访问
	lumia.price = 1999       // 简化访问
	lumia.act()
	fmt.Println(*lumia)
}
```

运行结果

```go
露米娅 打电话
{{1999 露米娅} 黑色}
```

## 7.3 覆盖

覆盖override，也称重写。

```go
package main

import (
	"fmt"
)

// 父结构体
type Phone struct {
	price int
	name  string
}

// 父结构体方法
func (P *Phone) act() {
	fmt.Println(P.name, "打电话")
}

// 子结构体
type Nokia struct {
	Phone
	color string
}

// 子结构体方法覆盖
func (N *Nokia) act() {
	fmt.Println(N.name, "砸核桃")
}

func main() {
	lumia := new(Nokia) // 实例化
	lumia.color = "黑色"
	lumia.Phone.name = "露米娅" // 完整访问
	lumia.price = 1999       // 简化访问
	lumia.act()              // 优先使用自己的方法
	lumia.Phone.act()        // 完整使用父结构体的方法
	fmt.Println(*lumia)
}

```

运行结果

```go
露米娅 砸核桃
露米娅 打电话
{{1999 露米娅} 黑色}
```

## 7.4 多态

```go
package main

import "fmt"

// 定义 Runner 接口
type Runer interface {
	run()
}

// 定义 Animal 父类
type Animal struct {
	name string
	age  int
}

// 定义 Cat 子类，继承 Animal
type Cat struct {
	Animal
}

// 定义 Dog 子类，继承 Animal
type Dog struct {
	Animal
}

// 定义 Animal 方法
func (A *Animal) run() {
	fmt.Println("Animal Run ~~~")
}

// 定义 Cat 方法
func (C *Cat) run() {
	C.Animal.run()
	fmt.Println("Cat Run ~~~")
}

// 定义 Dog 方法
func (D *Dog) run() {
	D.Animal.run()
	fmt.Println("Dog Run ~~~")
}

// 定义普通函数，入参为 Runner接口，通过传入不同实例实现多态
func TestRun(t Runer) {
	t.run()
	// 类型断言，操作不同实例的属性
	if v, ok := t.(*Cat); ok {
		v.age = 10
		v.name = "顽顽"
	}
	if v, ok := t.(*Dog); ok {
		v.age = 13
		v.name = "飞虎"
	}
}

func main() {
	c := new(Cat)
	d := new(Dog)

	TestRun(c)
	fmt.Printf("c.name: %v\n", c.name)
	TestRun(d)
	fmt.Printf("c.name: %v\n", d.name)
}
```

