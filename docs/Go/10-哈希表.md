# 一、哈希算法

把任意输入通过特定方式（hash函数） 处理后，生成一个值。这个值等同于存放数据的地址，这个地址里面再把输入的数据进行存储。这个hash函数又叫散列函数。

单向哈希算法 `y = hash(x)`：明文 → hash函数 → 密文，该运算不可逆。

- 把任意长度的输入值y，通过算法变成长度固定的输出值。
- 单向运算，无法找到逆运算的方法。
- 给定输入值 x，一定可以算出固定值 y。
- y值会有冲突、碰撞，由于输入空间无限，输出空间固定长度为有限数量，所以会出现 x1，x2不同输入，通过hash得到相同 y。
- 输入敏感，原始输入信息发生任何变化，新的 Hash 值都应该出现很大变化。

常用的 hash 算法：

- MD5：128bits，16bytes，32字符的字符串。
  - 运算速度快
  - 通常用于文件一致性对比
  - 数据库大字段内容对比
- SHA 系列，SHA1、SHA2、SHA256、SHA512
  - SHA512表示512bits，64bytes，128字符的字符串。
  - 运算速度略慢，通常用于数字签名

其中 md5 和 sha1 已被**彩虹表**所记录，可通过撞库逆向破解hash值。

```go
package main

import (
	"crypto/md5"
	"fmt"
)

func main() {
	hash := md5.New()
	s := "abcd"
	hash.Write([]byte(s))
	s1 := hash.Sum(nil)
	s2 := fmt.Sprintf("%x", s1)
	fmt.Printf("%+v, %[1]x,%v\n", s1, len(s2))
}
```

运行结果

```go
[226 252 113 76 71 39 238 147 149 243 36 205 46 127 51 31], e2fc714c4727ee9395f324cd2e7f331f,32
```

# 二、哈希表

哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字

| key  | value | hash(key) |
| ---- | ----- | --------- |
| A    | 101   | 4066      |
| B    | 102   | 1230      |
| C    | 103   | 4123      |
| D    | 104   | 4667      |
| E    | 105   | 3439      |

将key值hash后得到数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。

![image-20240422174314049](./10-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240422174314049.png)

## 2.1 Hash 碰撞

在数据量特别大的情况，如果计算出的hash值相同，那么其取模算出的数组索引也一致，这样会导致 hash 冲突/碰撞。

有两个常用的方法解决：

- 外部拉链法

主要思想是基于数组和链表的组合来解决冲突，桶（Bucket）中不直接存储键值对，每个Bucket都链接一个链表，当发生冲突时，将冲突的键值对插入链表中。

![image-20240422175344901](./10-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240422175344901.png)

- 开放定址法

主要思想是发生冲突时，直接去寻找下一个空的地址，只要底层的表足够大，就总能找到空的地址。这个寻找下一个地址的行为，叫做探测。

## 2.2 扩容

当数据量增多，链表过长后，查询效率逐渐变低，一般当负载因子（count / 2^B）> 6.5 时，这时会触发哈希表的扩容。

- count：当前表元素个数
- 2^B：桶数组个数

扩容策略：

- **增量扩容**：开辟一个新的桶数组，桶数组长度2^B++，桶的大小一定是2的次幂。这时候有老桶和新桶。

  新数据存新桶，同时老桶中数据需要迁移到新桶中（采用渐进式迁移，每次最多迁移2个桶）。

  有写入的时候，渐进式迁移，避免大量数据迁移。

- **等量扩容**：B保持不变，桶数组长度不变。指的是map的负载因子实际并不高，但每个桶的链表的节点上空洞太多，如果链表节点超过一定的阈值，则触发等量扩容，相当于链表重排，缩减链表的空洞。