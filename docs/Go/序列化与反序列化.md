# 一、定义

serialization 序列化：将内存中对象存储下来，把它变成一个个字节。转为二进制数据。

deserialization 反序列化：将文件的一个个字节恢复成内存中对象。从二进制数据中恢复。

序列化保存到文件就是持久化。

可以将数据序列化后持久化，或者网络传输；也可以将从文件中或者网络接收到的字节序列反序列化。

字符序列化：JSON、XML等

二进制序列化：Protocol Buffers、MessagePack等

# 二、JSON

JSON（JavaScript Object Notation, JS 对象标记）是一种轻量级的数据交换格式。它基于1999年发布的 ES3（ECMAScript是w3c组织制定的JavaScript规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。应该说，目前JSON得到几乎所有浏览器的支持。官方文档：https://www.json.org/json-zh.html

JSON 的数据类型：双引号引起来的字符串、数值、true和false、null、对象、数组，这些都是值

![image-20240307142418023](./%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20240307142418023.png)

```JSON
{
	"person": [
	 {
		"name": "tom",
		"age": 18
	 },
	 {
		"name": "jerry",
		"age": 16
	 }
   ],
	"total": 2
}
```

# 三、json包序列化

Go标准库中提供了`encoding/json`包，内部使用了反射技术，效率较为低下。

- `json.Marshal(v any) ([]byte, error)`，将v序列化成字符序列（本质上也是字节序列），这个过程称为Encode。

- `json.Unmarshal(data []byte, v any) error`，将字符序列data反序列化为v，这个过程称为Decode。

## 3.1 基本类型序列化

```go
package main

import (
	"encoding/json"
	"fmt"
)

var data = []any{
	100, 20.5, true, false, nil, "aabb", // 基本类型
	[3]int{97, 98, 99},                  // Go array => js array
	[]int{65, 66, 67},                   // Go slice => js array
	map[string]int{"abc": 49, "aa": 50}, // Go map => js object
}
var target = make([][]byte, 0, len(data))

func main() {
	// 序列化
	for i, v := range data { // 一个一个单独序列化，看变化
		b, err := json.Marshal(v)
		if err != nil {
			continue
		}
		fmt.Printf("%d %T: %[2]v => %T %[3]v %s\n", i, v, b, string(b))
		target = append(target, b)
	}
	fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
	// 反序列化
	for i, v := range target { // 一个一个单独反序列化，看变化
		var t any
		err := json.Unmarshal(v, &t)
		if err != nil {
			continue
		}
		fmt.Printf("%d %T: %[2]v => %T %[3]v\n", i, v, t)
	}
}
```

运行结果

```go
0 int: 100 => []uint8 [49 48 48] 100
1 float64: 20.5 => []uint8 [50 48 46 53] 20.5
2 bool: true => []uint8 [116 114 117 101] true
3 bool: false => []uint8 [102 97 108 115 101] false
4 <nil>: <nil> => []uint8 [110 117 108 108] null
5 string: aabb => []uint8 [34 97 97 98 98 34] "aabb"
6 [3]int: [97 98 99] => []uint8 [91 57 55 44 57 56 44 57 57 93] [97,98,99]
7 []int: [65 66 67] => []uint8 [91 54 53 44 54 54 44 54 55 93] [65,66,67]
8 map[string]int: map[aa:50 abc:49] => []uint8 [123 34 97 97 34 58 53 48 44 34 97 98 99 34 58 52 57 125] {"aa":50,"abc":49}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 []uint8: [49 48 48] => float64 100
1 []uint8: [50 48 46 53] => float64 20.5
2 []uint8: [116 114 117 101] => bool true
3 []uint8: [102 97 108 115 101] => bool false
4 []uint8: [110 117 108 108] => <nil> <nil>
5 []uint8: [34 97 97 98 98 34] => string aabb
6 []uint8: [91 57 55 44 57 56 44 57 57 93] => []interface {} [97 98 99]
7 []uint8: [91 54 53 44 54 54 44 54 55 93] => []interface {} [65 66 67]
8 []uint8: [123 34 97 97 34 58 53 48 44 34 97 98 99 34 58 52 57 125] => map[string]interface {} map[aa:50 abc:49]
```

数值被转换成了Go的 float64 类型；true、false 转成了 bool 型；null 转成了 nil；字符串转成了 string；数组转成了 []interface{}

## 3.2 结构体序列化

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Person struct {
	Name string
	Age  int
}

var data = Person{
	Name: "张三",
	Age:  18,
}

func main() {
	// 序列化
	b, err := json.Marshal(data)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(b))
	fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
	// 反序列化
	var b1 = []byte(string(b))
	var p Person
	err = json.Unmarshal(b1, &p)
	if err != nil {
		panic(err)
	}
	fmt.Println(p)
}
```

运行结果

```go
{"Name":"张三","Age":18}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{张三 18}
```

## 3.3 切片序列化

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Person struct {
	Name string
	Age  int
}

var data = []Person{
	{Name: "张三", Age: 18}, {Name: "李四", Age: 20},
}

func main() {
	// 序列化
	b, err := json.Marshal(data)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(b))
	fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
	// 反序列化
	var b1 = []byte(string(b))
	var p []Person
	err = json.Unmarshal(b1, &p)
	if err != nil {
		panic(err)
	}
	fmt.Println(p)
}
```

## 3.4 字段标签

结构体的字段可以增加标签tag，序列化、反序列化时使用

- 在字段类型后，可以跟反引号引起来的一个标签，用json为key，value用双引号引起来写，key 与 value 直接使用冒号，这个标签中不要加入多余空格，否则语法错误
  - Name string \`json:"name"`，这个例子序列化后得到的属性名为 name
    - 双引号内第一个参数用来指定字段转换使用的名称，多个参数使用逗号隔开
    - json表示json库使用
  - Name string \`json:"name,omitempty"`，omitempty为序列化时忽略空值，也就是该字段不序列化
    - 空值为false、0、空数组、空切片、空map、空串、nil空指针、nil接口值
    - 空数组、空切片、空串、空map，长度len为0，也就是容器没有元素
- 如果使用 - ，该字段将被忽略
  - Name string \`json:"-"`，序列化后没有该字段，反序列化也不会转换该字段
  - Name string \`json:"-,"`，序列化后该字段显示但名为 "-" ，反序列化也会转换该字段
- 多标签使用空格间隔
  - Name string \`json:"name,omitempty" msgpack:"myname"`

# 四、MessagePack库

MessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信。 它可以像JSON那样，在许多种语言之间交换结构对象。但是它比JSON更快速也更轻巧。 支持Python、Ruby、Java、C/C++、Go等众多语言。[MessagePack encoding for Go (uptrace.dev)](https://msgpack.uptrace.dev/)

## 4.1 安装

```go
go get github.com/vmihailenco/msgpack/v5
```

## 4.2 使用

```go
package main

import (
	"fmt"

	"github.com/vmihailenco/msgpack/v5"
)

type Item struct {
	Id   int
	Name string
}

var Phone = Item{
	Id:   20,
	Name: "诺基亚",
}

func main() {
	// 序列化
	b, err := msgpack.Marshal(&Phone)
	if err != nil {
		panic(err)
	}

	// 反序列化
	var item Item
	err = msgpack.Unmarshal(b, &item)
	if err != nil {
		panic(err)
	}
	fmt.Println(item)
}
```

