# 一、顺序表

开辟一段连续的内存空间，元素一个挨着一个保存在这个内存空间中，这样实现的表称为顺序表。go语言中：数组、切片都是顺序表实现。

顺序表定义赋值后自带元数据：首地址、容量 capacity、长度 length、偏移量（大小由数据类型决定）。

一、元素可索引：一般从0开始，最大索引为数据长度-1。

二、元素可定位：首地址+索引*每个元素所占字节数，即首地址+偏移量

![image-20240414190654201](./07-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20240414190654201.png)



## 查找

想要查找定位顺序表中的一个元素有两种方法：

1. 使用索引定位：首地址 + 索引 * 元素类型占的字节数，该方式时间复杂度为O(1)，定位最快，效率最高。
2. 使用内容遍历：遍历顺序表中的所有元素，直到找到匹配的元素，定位效率取决于元素个数，时间复杂度为O(n)。

由此可得，在元素数量特别大的时候，尽量使用索引定位元素的方式，效率最高。

## 新增

新增元素会触发扩容。

- 尾部追加元素：原有顺序表的元素无感知，顺序表只需长度+1，效率最高。
- 中间插入元素：顺序表长度增加，并且插入点后的所有元素需要往后移，数据量大的话，需要移动的元素较多，不推荐。
- 头部新增元素：原表的所有元素往后移，即所有元素都需要操作，非常不推荐。

## 删除

- 与新增类似，尾部删除代价最小，效率最高。
- 中间或者头部删除元素，需要移动被影响的元素，代价略高。

## 修改

查找定位到，然后覆盖该元素

# 二、链接表

在存储空间中将分散存储的元素链接起来，这种实现称为链接表，简称链表。go语言中，list为链表结构。

链接表定义赋值后自带元数据：头 head、尾 tail、长度 length。

![image-20240415114127385](./07-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20240415114127385.png)

## 查找

想要查找定位顺序表中的一个元素有两种方法：

1. 使用索引定位：由于有head、tail指针位置、length长度，可直接算出头、尾的索引地址效率最高。中间位置则需要遍历。
2. 使用内容遍历：遍历顺序表中的所有元素，直到找到匹配的元素，定位效率取决于元素个数，时间复杂度为O(n)。

由此可得，在元素数量特别大的时候，尽量只变动头尾元素，效率最高。

## 新增

新增元素不会触发扩容，随机找空间插入元素。

- 尾部追加元素：原有链接表的元素无感知，Tail指针指向新元素，原尾部元素的next指向新元素地址，新元素的prev指向老尾部地址即可。
- 中间插入元素：头尾都不会有影响，只影响插入节点的前后两个元素，需要重新指定prev、next。
- 头部新增元素：与尾部追加相反，Head指针指向新元素，原头部元素prev指向新元素地址，新元素next指向原老头部地址。

## 删除

影响元素与新增类似，只涉及到部分元素的prev与next指向变动。

## 修改

查找定位到，然后覆盖该元素