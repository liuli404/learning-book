# 一、理解协程

<u>*参考连接：https://www.cnblogs.com/xiaoyangjia/p/16640741.html*</u>

协程（Coroutines）的完整定义是“协作式调度的用户态线程”。首先，要理解线程调度的两种方式：

1. 协作式调度：当前线程完全占用CPU时间，除非自己让出时间片，直到运行结束，系统才执行下一个线程。可能出现一个线程一直占有CPU，而其他线程等待。
2. 抢占式调度：操作系统决定下一个占用CPU时间的是哪一个线程，定期的中断当前正在执行的线程，任何一个线程都不能独占。不会因为一个线程而影响整个进程的执行。

另外，要理解**用户态**和**内核态**的概念。

​	操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。有些CPU 的指令是非常危险的，一旦用错可能导致系统崩溃。如果所有的程序都可以任意使用这些指令，那么系统崩溃的概率将大大增加。为了保证内核的安全，操作系统一般都**禁止用户进程直接操作内核**。

​	具体的实现方式是将虚拟内存空间划分为两部分，一部分为**内核空间**，另一部分为**用户空间**。当进程运行在内核空间时就处于内核态，进程运行在用户空间时则处于用户态。

​	无论是进程还是线程，它们的上下文切换和"内核态、用户态"没有直接的关系。比如只要需要系统调用，即使不做任何切换，都需要进入内核态。举个例子：一个线程调用函数在屏幕上打印 hello world，就已经进入了内核态了，因为打印字符的功能是由内核程序提供的。

总的来说，应用程序通常运行在用户态，遇到下列三种情况会切换到内核态：

- 系统调用：创建和调度线程、加锁解锁等等。
- 异常事件：发生不可知的异常时切换到内核态，以执行相关的异常事件。
- 设备中断：如果外围设备完成了用户请求，比如硬盘读写操作，就会给CPU发送中断信号。CPU会转去处理中断事件，切换到内核态。

线程的代码在用户态运行，而调度是在内核态运行的。操作系统切换线程上下文的步骤如下所示：

1. 保留用户态现场（上下文、寄存器、用户栈等）
2. 复制用户态参数，用户栈切到内核栈，进入内核态
3. 代码安全检查（内核不信任用户态代码）
4. 执行内核态代码
5. 复制内核态代码执行结果，回到用户态
6. 恢复用户态现场（上下文、寄存器、用户栈等）

​	协程不是操作系统的底层特性，系统感知不到它的存在。它运行在**线程**里面，通过**分时复用线程**的方式运行，不会增加线程的数量。协程也有上下文切换，但是不会切换到内核态去，比线程切换的开销要小很多。每个协程的体积比线程要小得多，一个线程可以容纳数量相当可观的协程。

​	在IO密集型的任务中有着大量的阻塞等待过程，协程采用协作式调度，在IO阻塞的时候让出CPU，当IO就绪后再主动占用CPU，牺牲任务执行的公平性换取吞吐量。

协程也存在几个弊端：

- 线程可以在多核CPU上并行，无法将一个线程的多个协程分摊到多核上。
- 协程执行中不能有阻塞操作，否则整个线程被阻塞。
- 协程的控制权由用户态决定，可能执行恶意的代码。

# 二、函数暂停实现原理

以 Python 为例，使用 yield 实现生成器函数。生成器对象就是迭代器对象，不过是特殊语法构造出的迭代器对象。

- 可以使用next函数驱动它执行，但执行到yield就暂停函数执行
- 可以使用for循环迭代它，相当于连续的next，直到不可迭代为止
- 只能单向向后迭代，不可以重头开始

```python
def num():
    for i in range(5):
        print(i)
        yield


def str():
    for i in "ABCDE":
        print(i)
        yield i


if __name__ == '__main__':
    t1 = num()  # 迭代器对象
    t2 = str()  # 迭代器对象
    while True:
        next(t1, None)
        next(t2, None)
```

运行结果

```go
0
A
1
B
2
C
3
D
4
E
```

可以看出代码在yield处暂停，通过next来驱动各个函数执行，可以由程序员在合适的地方通过yield来暂 停一个函数执行，让另外一个函数执行。

暂停是一种非常重要的能力，以前函数正常要执行到return后，现在可以由开发者控制暂停执行的时 机。而线程时间片用完导致的函数切换对开发人员来说是不可控的，而且线程控制能力是内核的功能， 是在内核态完成的，而上例（协程）的控制是在用户态完成的。

协程给了第一个可由程序员在用户态控制任务调度的能力。

# 三、GMP 模型 ★

*参考文章：*[GMP原理与调度](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html)

## 3.1 GMP 模型

Go协程调度中，有三个重要角色：

- G：Goroutine，Go协程。存储了协程的执行栈信息、状态和任务函数等。初始栈大小约为2~4k， 理论上开启百万个Goroutine不是问题。
- M：Machine Thread，对系统线程抽象、封装。所有代码最终都要在系统线程上运行，协程最终也是代码，也不例外。
- P：Processor（Go1.1版本引入），虚拟处理器
  - 可以通过环境变量 GOMAXPROCS 或 runtime.GOMAXPROCS() 设置
  - 默认为CPU核心数，P的数量决定着最大可并行的G的数量
  - P有自己的队列（长度256），里面放着待执行的G
  - M和P需要绑定在一起，这样P队列中的G才能真正在线程上执行

![image-20240604134549965](./22-Goroutine%E5%8D%8F%E7%A8%8B/image-20240604134549965.png)

> 有关 P 和 M 的个数问题

1、P 的数量：

- 由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。

2、M 的数量:

- go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量
- 一个 M 阻塞了，会创建新的 M。

M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

> P 和 M 何时会被创建

1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。

2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。

## 3.2 调度器的设计策略

1、复用线程：避免频繁的创建、销毁线程，而是对线程的复用。

1. work stealing 机制

   当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。

2. hand off 机制

   当本线程因为 G 进行**系统调用**阻塞时，M 线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

2、利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

3、抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。

4、全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

## 3.3 go func () 调度流程

![image-20240604150757453](./22-Goroutine%E5%8D%8F%E7%A8%8B/image-20240604150757453.png)

1. 我们通过 go func () 来创建一个 goroutine。
2. 有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。
   - 新创建的 G 会先保存在 P 的本地队列中
   - 如果 P 的本地队列已经满了就会保存在全局的队列中
3. G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。
   - M 会从 P 的本地队列弹出一个可执行状态的 G 来执行
   - 如果 P 的本地队列为空，就从全局队列中请求G
   - 如果全局队列为空，就从network poller中拿一个runnable的G
   - 如果还是空的，就从其他的 MP 组合偷取**一半**可执行的 G 放到自己的本地队列
4. M 最终拿到 G，开始执行，一个 M 调度 G 执行的过程是一个循环机制。
5. 当 M 执行某一个 G 时候，会有以下情况：

- G 正常执行完了（函数调用完成了），G 和 M 解绑，执行第3步的获取下一个可执行的 G。

- 如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；

 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。

# 四、Go 协程创建与管理

使用 `go` 关键词 + `函数名` 直接启动一个协程运行函数。

```go
package main

import (
	"fmt"
)

func hello() {
	fmt.Println("Hello goroutine")
}

func main() {
	fmt.Println("Mian goroutine start")
	go hello()
	fmt.Println("Mian goroutine done")
}
```

运行结果：

```go
Mian goroutine start
Mian goroutine done
```

为什么没有打印 `Hello goroutine` 信息？

在程序启动时，Go程序就会为`main()`函数创建一个默认的`goroutine`。所以当`main`函数运行完毕，当前`goroutine`结束，那么在`main`函数中启动的`goroutine`会一同结束，所以启动的`hello`函数协程还没来得及运行就被结束了。

## 4.1 等待组

使用 `sync.WaitGroup` 来等待创建的协程都正常执行完成。

```go
package main

import (
	"fmt"
	"sync"
)

func hello(wg *sync.WaitGroup) {
	defer wg.Done() // goroutine结束就登记-1
	fmt.Println("Hello goroutine")
}

func main() {
	var wg sync.WaitGroup
	wg.Add(1) // 启动一个goroutine就计数+1
	fmt.Println("Mian goroutine start")
	go hello(&wg)
	wg.Wait() // 等待所有登记的goroutine都结束，再执行后面程序
	fmt.Println("Mian goroutine done")
}
```

运行结果

```go
Mian goroutine start
Hello goroutine
Mian goroutine done
```

## 4.2 父子协程

一个协程A中创建了另外一个协程B，A称作父协程，B称为子协程。

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		fmt.Println("父协程~~~~~~~~~~")
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			fmt.Println("子协程*************")
		}(wg)
	}(&wg)
	fmt.Println("主协程##########")
	wg.Wait()
}
```

运行结果

```go
主协程##########
父协程~~~~~~~~~~
子协程*************
```

父协程结束执行，子协程不会有任何影响。当然子协程结束执行，也不会对父协程有什么影响。父子协 程没有什么特别的依赖关系，各自独立运行。

