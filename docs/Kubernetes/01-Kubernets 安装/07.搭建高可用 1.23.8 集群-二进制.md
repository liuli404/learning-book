# 一、集群信息

## 1.1 主机规划

| 主机名称     | IP地址        | 软件                                                         |
| ------------ | ------------- | ------------------------------------------------------------ |
| master01     | 10.11.141.11  | kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd、runc |
| master02     | 10.11.141.12  | kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd、runc |
| master03     | 10.11.141.13  | kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd、runc |
| worker01     | 10.11.141.21  | kubelet、kube-proxy、containerd、runc                        |
| worker02     | 10.11.141.22  | kubelet、kube-proxy、containerd、runc                        |
| vip          | 10.11.141.100 |                                                              |
| proxy.server | 10.11.141.10  | yum 源、harbor 服务器、chronyd 服务端、dns 服务器            |

## 1.2 软件版本

| 软件           | 版本     | 下载地址                                                     |
| -------------- | :------- | ------------------------------------------------------------ |
| CentOS         | 7.9-2009 |                                                              |
| 内核           | 5.18.14  |                                                              |
| kubernetes     | 1.23.8   | https://dl.k8s.io/v1.23.8/kubernetes-server-linux-amd64.tar.gz |
| etcd           | 3.5.4    | https://github.com/etcd-io/etcd/releases/download/v3.5.4/etcd-v3.5.4-linux-amd64.tar.gz |
| containerd     | 1.6.6    | https://github.com/containerd/containerd/releases/download/v1.6.6/cri-containerd-cni-1.6.6-linux-amd64.tar.gz |
| cfssl          | 1.6.1    | https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssl_1.6.1_linux_amd64 |
| cfssljson      | 1.6.1    | https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64 |
| cfssl-certinfo | 1.6.1    | https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssl-certinfo_1.6.1_linux_amd64 |
| calico         | 3.19.4   | https://docs.projectcalico.org/v3.19/manifests/calico.yaml   |
| coredns        | 1.8.4    |                                                              |
| runc           | 1.1.2    |                                                              |
| libseccomp     | 2.5.1    | http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm |

## 1.3 网络规划

| 环境    | 网段        | 掩码 |
| ------- | ----------- | ---- |
| 主机    | 10.11.141.0 | 24   |
| service | 10.96.0.0   | 16   |
| pod     | 10.244.0.0  | 16   |

# 二、系统环境配置

## 2.1 设置主机名

```shell
# 给每台主机设置主机名
hostnamectl set-hostname master01
hostnamectl set-hostname master02
hostnamectl set-hostname master03
hostnamectl set-hostname worker01
hostnamectl set-hostname worker02
```

## 2.2 配置 DNS 服务器

在网卡的配置文件 `/etc/sysconfig/network-scripts/ifcfg-ens33` 中修改或添加一个 DNS 服务器地址即可：

```shell
DNS1=10.11.141.10
```

重启网卡

```bash
systemctl restart network
```

## 2.3 关闭防火墙、Selinux

```shell
systemctl stop firewalld.service && systemctl disable firewalld.service
setenforce 0 && sed -i 's/enforcing/disabled/g' /etc/selinux/config
```

## 2.4 配置 YUM 源

```shell
mv /etc/yum.repos.d/* /tmp/
```

```bash
cat > /etc/yum.repos.d/local.repo << EOF
[base]
name=CentOS-Base
baseurl=http://10.11.141.10/base/Packages/
enabled=1
gpgcheck=0
 
[epel]
name=CentOS-Epel
baseurl=http://10.11.141.10/epel/Packages/
enabled=1
gpgcheck=0
 
[extras]
name=CentOS-Extras
baseurl=http://10.11.141.10/extras/Packages/
enabled=1
gpgcheck=0

[updates]
name=CentOS-Updates
baseurl=http://10.11.141.10/updates/Packages/
enabled=1
gpgcheck=0
EOF
```

```bash
yum clean all && yum makecache
```

## 2.5 配置时间同步

```shell
cat > /etc/chrony.conf << EOF
server 10.11.141.10 iburst
driftfile /var/lib/chrony/drift
makestep 1.0 3
rtcsync
logdir /var/log/chrony
EOF
```

```bash
systemctl restart chronyd && systemctl enable chronyd && systemctl status chronyd
```

验证是否连接到自建 NTP 服务器

```bash
chronyc sourcestats -v
```

## 2.6 关闭 swap

```bash
swapoff -a && sed -i '/swap/d' /etc/fstab
```

## 2.7 安装基本工具

```shell
yum install -y vim wget net-tools bash-completion lrzsz
source /usr/share/bash-completion/bash_completion
```

## 2.8 主机系统优化

```bash
ulimit -SHn 65535
```

```bash
cat >> /etc/security/limits.conf << EOF
* soft nofile 655360
* hard nofile 131072
* soft nproc 655350
* hard nproc 655350
* soft memlock unlimited
* hard memlock unlimited
EOF
```

## 2.9 配置 ipvs 模块

```bash
yum -y install ipvsadm ipset sysstat conntrack libseccomp
```

所有节点配置 ipvs 模块

```bash
cat > /etc/modules-load.d/ipvs.conf << EOF 
ip_vs
ip_vs_lc
ip_vs_wlc
ip_vs_rr
ip_vs_wrr
ip_vs_lblc
ip_vs_lblcr
ip_vs_dh
ip_vs_sh
ip_vs_nq
ip_vs_sed
ip_vs_ftp
ip_vs_sh
nf_conntrack
ip_tables
ip_set
xt_set
ipt_set
ipt_rpfilter
ipt_REJECT
ipip
EOF
```

## 2.10 配置 containerd 模块

所有 containerd 节点加载模块

```bash
cat > /etc/modules-load.d/containerd.conf << EOF
overlay
br_netfilter
EOF
```

```bash
systemctl enable --now systemd-modules-load.service
```

## 2.11 配置免密登录

```shell
# 生成密钥
ssh-keygen

# 配置免密，方便分发文件
export IP="10.11.141.100 10.11.141.11 10.11.141.12 10.11.141.13 10.11.141.21 10.11.141.22"
for HOST in $IP;do ssh-copy-id $HOST;done
```

## 2.12 内核调优

```bash
cat > /etc/sysctl.d/kubernetes.conf << EOF 
# 开启数据包转发功能（实现vxlan）
net.ipv4.ip_forward = 1
# 不允许将TIME-WAIT sockets重新用于新的TCP连接
net.ipv4.tcp_tw_reuse = 0
# 持久连接
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 10
# 关闭 swap 分区
vm.swappiness = 0
# socket 监听(listen)的 backlog 上限
net.core.somaxconn = 32768
# 最大跟踪连接数，默认 nf_conntrack_buckets * 4
net.netfilter.nf_conntrack_max = 1000000
# 计算当前的内存映射文件数。
vm.max_map_count = 655360
# 内核可分配的最大文件数
fs.file-max = 6553600
EOF	
```

刷新生效

```bash
sysctl -p /etc/sysctl.d/kubernetes.conf
```

## 2.13 升级内核

查看当前系统内核版本

```shell
$ uname -r
3.10.0-1160.el7.x86_64
```

创建自建 yum 源文件

```shell
cat > /etc/yum.repos.d/elrepo.repo << EOF
[elrepo]
name=elrepo
baseurl=http://10.11.141.10/elrepo/
enabled=1
gpgcheck=0
EOF
```

重新生成缓存

```bash
yum clean all && yum makecache
```

安装 kernel-ml 内核

```bash
yum install -y kernel-ml
```

查看系统启动 grub2 中配置的内核

```shell
sudo awk -F\' '$1=="menuentry " {print i++ " : " $2}' /etc/grub2.cfg
0 : CentOS Linux (5.18.14-1.el7.elrepo.x86_64) 7 (Core)
1 : CentOS Linux (3.10.0-1160.el7.x86_64) 7 (Core)
2 : CentOS Linux (0-rescue-8e0eacdd7a194d91967c04152ffa0d0e) 7 (Core)
# 设置默认内核为 0
grub2-set-default 0
# 重新创建内核配置
grub2-mkconfig -o /boot/grub2/grub.cfg
```

`reboot`重启后生效

```shell
$ uname -r
5.18.10-1.el7.elrepo.x86_64
```

## 2.14 重启后验证

- 防火墙状态

```bash
$ systemctl status firewalld.service
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
```

- Selinux 状态

```bash
$ getenforce
Disabled
```

- 时间同步

```bash
$ chronyc sourcestats -v
210 Number of sources = 1
                             .- Number of sample points in measurement set.
                            /    .- Number of residual runs with same sign.
                           |    /    .- Length of measurement set (time).
                           |   |    /      .- Est. clock freq error (ppm).
                           |   |   |      /           .- Est. error in freq.
                           |   |   |     |           /         .- Est. offset.
                           |   |   |     |          |          |   On the -.
                           |   |   |     |          |          |   samples. \
                           |   |   |     |          |          |             |
Name/IP Address            NP  NR  Span  Frequency  Freq Skew  Offset  Std Dev
==============================================================================
proxy.server                4   3     6     +0.673     17.607    +26us  1738ns
```

- 交换分区

```bash
$ cat /proc/sys/vm/swappiness
0
```

- 资源限制

```bash
$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7700
max locked memory       (kbytes, -l) unlimited
max memory size         (kbytes, -m) unlimited
open files                      (-n) 131072
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 655350
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

- ipvs 模块

```bash
$ lsmod | grep -e 'ip_vs' -e 'nf_conntrack'
ip_vs_ftp              16384  0 
nf_nat                 49152  1 ip_vs_ftp
ip_vs_sed              16384  0 
ip_vs_nq               16384  0 
ip_vs_sh               16384  0 
ip_vs_dh               16384  0 
ip_vs_lblcr            16384  0 
ip_vs_lblc             16384  0 
ip_vs_wrr              16384  0 
ip_vs_rr               16384  0 
ip_vs_wlc              16384  0 
ip_vs_lc               16384  0 
ip_vs                 159744  22 ip_vs_wlc,ip_vs_rr,ip_vs_dh,ip_vs_lblcr,ip_vs_sh,ip_vs_nq,ip_vs_lblc,ip_vs_wrr,ip_vs_lc,ip_vs_sed,ip_vs_ftp
nf_conntrack          151552  2 nf_nat,ip_vs
nf_defrag_ipv6         24576  2 nf_conntrack,ip_vs
nf_defrag_ipv4         16384  1 nf_conntrack
libcrc32c              16384  4 nf_conntrack,nf_nat,xfs,ip_vs
```

- containerd 模块

```bash
$ lsmod | grep -e 'br_netfilter' -e 'overlay'
br_netfilter           28672  0 
overlay               135168  0
```

# 三、安装 cfssl 工具

```bash
# 所有节点创建两个工作目录存放文件
mkdir -p /root/k8s_install/{ssl,soft}
```

> master01 执行该步骤

```bash
# 将下载的所有文件上传至该目录
cd /root/k8s_install/soft
```

```bash
chmod +x cfssl*
mv cfssl_1.6.1_linux_amd64 /usr/local/bin/cfssl
mv cfssljson_1.6.1_linux_amd64 /usr/local/bin/cfssljson
mv cfssl-certinfo_1.6.1_linux_amd64 /usr/local/bin/cfssl-certinfo
```

```bash
$ cfssl version
Version: 1.6.1
Runtime: go1.12.12
```

## 3.1 创建 ca 证书请求模版

```bash
cd /root/k8s_install/ssl
```

```json
cat > ca-csr.json << EOF
{
  "CN": "kubernetes",
  "key": {
      "algo": "rsa",
      "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Beijing",
      "L": "Beijing",
      "O": "digitalchina",
      "OU": "CN"
    }
  ],
  "ca": {
          "expiry": "87600h"
  }
}
EOF
```

## 3.2 创建 ca 证书

```bash
cfssl gencert -initca ca-csr.json | cfssljson -bare ca
```

## 3.3 创建 ca 证书策略模版

```json
cat > ca-config.json << EOF
{
  "signing": {
      "default": {
          "expiry": "87600h"
        },
      "profiles": {
          "kubernetes": {
              "usages": [
                  "signing",
                  "key encipherment",
                  "server auth",
                  "client auth"
              ],
              "expiry": "87600h"
          }
      }
  }
}
EOF
```

```bash
$ ls
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
```

# 四、部署 etcd 集群

> 先在 master01 上操作，然后分发文件到 master02、master03

## 4.1 创建 etcd 证书

配置 etcd 请求模版文件

```json
cat > etcd-csr.json << EOF
{
  "CN": "etcd",
  "hosts": [
    "127.0.0.1",
    "10.11.141.11",
    "10.11.141.12",
    "10.11.141.13",
    "master01",
    "master02",
    "master03"
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [{
    "C": "CN",
    "ST": "Beijing",
    "L": "Beijing",
    "O": "digitalchina",
    "OU": "CN"
  }]
}
EOF
```

 生成 etcd 证书

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd
```

```bash
$ ls
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem  etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem
```



## 4.2 配置 etcd 集群

创建配置文件目录

```bash
mkdir -p /etc/etcd/ssl
mkdir -p /var/lib/etcd/default.etcd
```

配置证书

```bash
cp ca*.pem /etc/etcd/ssl
cp etcd*.pem /etc/etcd/ssl
```

解压安装包

```bash
cd /root/k8s_install/soft
```

```bash
tar -zxvf etcd-v3.5.4-linux-amd64.tar.gz
cp etcd-v3.5.4-linux-amd64/etcd* /usr/local/bin/
```

创建配置文件

```bash
cat > /etc/etcd/etcd.conf <<"EOF"
#[Member]
ETCD_NAME="etcd1"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://10.11.141.11:2380"
ETCD_LISTEN_CLIENT_URLS="https://10.11.141.11:2379,http://127.0.0.1:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://10.11.141.11:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://10.11.141.11:2379"
ETCD_INITIAL_CLUSTER="etcd1=https://10.11.141.11:2380,etcd2=https://10.11.141.12:2380,etcd3=https://10.11.141.13:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"
EOF
```

配置说明

```powershell
ETCD_NAME：节点名称，集群中唯一
ETCD_DATA_DIR：数据目录
ETCD_LISTEN_PEER_URLS：集群通信监听地址
ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址
ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址
ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址
ETCD_INITIAL_CLUSTER：集群节点地址
ETCD_INITIAL_CLUSTER_TOKEN：集群Token
ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群
```

创建 systemd 守护进程文件

```bash
cat > /etc/systemd/system/etcd.service <<"EOF"
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=-/etc/etcd/etcd.conf
WorkingDirectory=/var/lib/etcd/
ExecStart=/usr/local/bin/etcd \
  --cert-file=/etc/etcd/ssl/etcd.pem \
  --key-file=/etc/etcd/ssl/etcd-key.pem \
  --trusted-ca-file=/etc/etcd/ssl/ca.pem \
  --peer-cert-file=/etc/etcd/ssl/etcd.pem \
  --peer-key-file=/etc/etcd/ssl/etcd-key.pem \
  --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \
  --peer-client-cert-auth \
  --client-cert-auth
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
```

## 4.3 分发文件

master02、master03 创建对应目录

```bash
mkdir -p /etc/etcd/ssl
mkdir -p /var/lib/etcd/default.etcd
```

- 分发证书

```bash
cd /root/k8s_install/ssl
```

```bash
scp ca*.pem 10.11.141.12:/etc/etcd/ssl
scp ca*.pem 10.11.141.13:/etc/etcd/ssl
scp etcd*.pem 10.11.141.12:/etc/etcd/ssl
scp etcd*.pem 10.11.141.13:/etc/etcd/ssl
```

- 分发软件包

```bash
cd /root/k8s_install/soft
```

```bash
scp etcd-v3.5.4-linux-amd64/etcd* 10.11.141.12:/usr/local/bin/
scp etcd-v3.5.4-linux-amd64/etcd* 10.11.141.13:/usr/local/bin/
```

- 分发 systemd  守护进程文件

```bash
scp /etc/systemd/system/etcd.service 10.11.141.12:/etc/systemd/system/
scp /etc/systemd/system/etcd.service 10.11.141.13:/etc/systemd/system/
```

master02 创建配置文件

```bash
cat > /etc/etcd/etcd.conf << EOF
#[Member]
ETCD_NAME="etcd2"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://10.11.141.12:2380"
ETCD_LISTEN_CLIENT_URLS="https://10.11.141.12:2379,http://127.0.0.1:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://10.11.141.12:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://10.11.141.12:2379"
ETCD_INITIAL_CLUSTER="etcd1=https://10.11.141.11:2380,etcd2=https://10.11.141.12:2380,etcd3=https://10.11.141.13:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"
EOF
```

master03 创建配置文件

```bash
cat > /etc/etcd/etcd.conf << EOF
#[Member]
ETCD_NAME="etcd3"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://10.11.141.13:2380"
ETCD_LISTEN_CLIENT_URLS="https://10.11.141.13:2379,http://127.0.0.1:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://10.11.141.13:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://10.11.141.13:2379"
ETCD_INITIAL_CLUSTER="etcd1=https://10.11.141.11:2380,etcd2=https://10.11.141.12:2380,etcd3=https://10.11.141.13:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"
EOF
```

## 4.4 验证集群

三个节点启动 etcd

```bash
systemctl daemon-reload
systemctl enable --now etcd.service
systemctl status etcd
```

验证集群状态

```bash
ETCDCTL_API=3 /usr/local/bin/etcdctl --write-out=table --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem --endpoints=https://10.11.141.11:2379,https://10.11.141.12:2379,https://10.11.141.13:2379 endpoint health
```

```bash
ETCDCTL_API=3 /usr/local/bin/etcdctl --write-out=table --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem --endpoints=https://10.11.141.11:2379,https://10.11.141.12:2379,https://10.11.141.13:2379 member list
```

```bash
ETCDCTL_API=3 /usr/local/bin/etcdctl --write-out=table --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem --endpoints=https://10.11.141.11:2379,https://10.11.141.12:2379,https://10.11.141.13:2379 endpoint status
```

#  五、安装 containerd

containerd 作为 k8s 的容器运行时，所有运行容器的节点都要安装

## 5.1 分发 containerd 软件包

```bash
cd /root/k8s_install/soft
```

分发到所有节点

```shell
cat > containerd.sh << 'EOF'
containerd=/root/k8s_install/soft/cri-containerd-cni-1.6.6-linux-amd64.tar.gz
libseccomp=/root/k8s_install/soft/libseccomp-2.5.1-1.el8.x86_64.rpm
IP="10.11.141.11 10.11.141.12 10.11.141.13 10.11.141.21 10.11.141.22"
for HOST in ${IP[@]}
do 
    scp $containerd $HOST:/root/k8s_install/soft
    scp $libseccomp $HOST:/root/k8s_install/soft
done 
EOF
```

```bash
bash containerd.sh
```

## 5.2 创建配置文件

> 所有 containerd 节点同步操作

```bash
cd /root/k8s_install/soft
tar -xzvf cri-containerd-cni-1.6.6-linux-amd64.tar.gz -C /
```

```shell
mkdir -p /etc/containerd/
containerd config default > /etc/containerd/config.toml
```

修改 `/etc/containerd/config.toml`  配置文件

```toml
# 1.修改 SystemdCgroup
#SystemdCgroup = false
SystemdCgroup = true

# 2.修改 sandbox_image 地址，确保自建 harbor 中有该镜像
#sandbox_image = "k8s.gcr.io/pause:3.6" 
sandbox_image = "proxy.localharbor.com/google_imgs/pause:3.6"

# 3.连接自建 harbor 仓库
      [plugins."io.containerd.grpc.v1.cri".registry.auths]
        [plugins."io.containerd.grpc.v1.cri".registry.configs."proxy.localharbor.com".auth]
          username = "admin"
          password = "Harbor12345"
          
      [plugins."io.containerd.grpc.v1.cri".registry.configs]
        [plugins."io.containerd.grpc.v1.cri".registry.configs."proxy.localharbor.com".tls]
          insecure_skip_verify = true

      [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
        [plugins."io.containerd.grpc.v1.cri".registry.mirrors."proxy.localharbor.com"]
         endpoint = ["https://proxy.localharbor.com"]
```

针对 containerd 内核调优

```shell
cat > /etc/sysctl.d/containerd.conf << EOF 
# iptables 对 bridge 的数据进行处理
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-arptables = 1
EOF
```

```shell
sysctl -p /etc/sysctl.d/containerd.conf
```

## 4.4 启动服务

```shell
systemctl start containerd && systemctl enable containerd
```

## 4.5 升级 libseccomp

`centos7 ` 中 yum 下载的 libseccomp 版本是 2.3 的，版本不满足我们最新 containerd 的需求，会导致 `runc` 报错。

```shell
$ runc
runc: symbol lookup error: runc: undefined symbol: seccomp_notify_respond
```

```shell
# 查看当前版本
$ rpm -qa | grep libseccomp
libseccomp-2.3.1-4.el7.x86_64

# 卸载旧版本
rpm -e libseccomp-2.3.1-4.el7.x86_64 --nodeps

# 安装
rpm -ivh /root/k8s_install/soft/libseccomp-2.5.1-1.el8.x86_64.rpm

# 查看当前版本
$ rpm -qa | grep libseccomp
libseccomp-2.5.1-1.el8.x86_64

$ runc --version
runc version 1.1.2
commit: v1.1.2-0-ga916309f
spec: 1.0.2-dev
go: go1.17.11
libseccomp: 2.5.1
```

重启 containerd 服务

```shell
systemctl restart containerd
```

## 4.6 安装 cri 客户端

```shell
# 连接 containerd
cat > /etc/crictl.yaml << EOF
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

# 测试连接
systemctl restart containerd
$ crictl info
```

# 六、kubernetes 组件部署

## 6.1 软件分发

解压安装包

```bash
cd /root/k8s_install/soft
tar -zxvf kubernetes-server-linux-amd64.tar.gz
cd kubernetes/server/bin/
```

master 节点组件分发

```bash
scp kube-apiserver kube-controller-manager kube-scheduler kubectl kubelet kube-proxy 10.11.141.11:/usr/local/bin
scp kube-apiserver kube-controller-manager kube-scheduler kubectl kubelet kube-proxy 10.11.141.12:/usr/local/bin
scp kube-apiserver kube-controller-manager kube-scheduler kubectl kubelet kube-proxy 10.11.141.13:/usr/local/bin
```

work 节点组件分发

```bash
scp kubelet kube-proxy 10.11.141.21:/usr/local/bin
scp kubelet kube-proxy 10.11.141.22:/usr/local/bin
```

所有节点创建目录

```bash
mkdir -p /etc/kubernetes/pki
mkdir -p /var/log/kubernetes
mkdir -p /var/lib/kubelet
mkdir -p /var/lib/kube-proxy
mkdir -p /root/.kube
```

## 6.2 部署 api-server

### 6.2.1 创建证书请求文件

```bash
cd /root/k8s_install/ssl/
```

为了方便后期扩容可以多写几个预留的 IP（含VIP），同时还需要填写 service 网络的首个 IP (一般是 kube-apiserver 指定的 service-cluster-ip-range 网段的第一个IP，如 10.96.0.1)

```json
cat > kube-apiserver-csr.json << "EOF"
{
"CN": "kubernetes",
  "hosts": [
    "127.0.0.1",
    "10.11.141.100",
    "10.11.141.11",
    "10.11.141.12",
    "10.11.141.13",
    "10.10.10.14",
    "10.10.10.15",
    "10.10.10.16",
    "10.10.10.17",
    "10.10.10.18",
    "10.10.10.19",
    "10.96.0.1",
    "kubernetes",
    "kubernetes.default",
    "kubernetes.default.svc",
    "kubernetes.default.svc.cluster",
    "kubernetes.default.svc.cluster.local"
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Beijing",
      "L": "Beijing",
      "O": "digitalchina",
      "OU": "CN"
    }
  ]
}
EOF
```

### 6.2.2 生成证书及 token 文件

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-apiserver-csr.json | cfssljson -bare kube-apiserver
```

```bash
cat > token.csv << EOF
$(head -c 16 /dev/urandom | od -An -t x | tr -d ' '),kubelet-bootstrap,10001,"system:kubelet-bootstrap"
EOF
```

> TLS Bootstraping: Master apiserver 启用 TLS 认证后，Node 节点 kubelet 和 kube-proxy 与 kube-apiserver 进行通信，必须使用 CA 签发的有效证书才可以，当 Node 节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。为了简化流程，Kubernetes 引入了 TLS bootstraping 机制来自动颁发客户端证书，kubelet 会以一个低权限用户自动向 apiserver 申请证书，kubelet 的证书由 apiserver 动态签署。所以强烈建议在 Node 上使用这种方式，目前主要用于 kubelet，kube-proxy 还是由我们统一颁发一个证书。

### 6.2.3 创建配置文件

```bash
cat > kube-apiserver.service << "EOF"
[Unit]
Description=Kubernetes API Server
After=etcd.service
Wants=etcd.service

[Service]
ExecStart=/usr/local/bin/kube-apiserver \
  --bind-address=0.0.0.0 \
  --secure-port=6443  \
  --service-cluster-ip-range=10.96.0.0/16 \
  --service-node-port-range=30000-32767 \
  --etcd-servers=https://10.11.141.11:2379,https://10.11.141.12:2379,https://10.11.141.13:2379 \
  --etcd-cafile=/etc/etcd/ssl/ca.pem \
  --etcd-certfile=/etc/etcd/ssl/etcd.pem \
  --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem \
  --client-ca-file=/etc/kubernetes/pki/ca.pem \
  --tls-cert-file=/etc/kubernetes/pki/kube-apiserver.pem \
  --tls-private-key-file=/etc/kubernetes/pki/kube-apiserver-key.pem \
  --service-account-key-file=/etc/kubernetes/pki/ca-key.pem \
  --service-account-signing-key-file=/etc/kubernetes/pki/ca-key.pem \
  --service-account-issuer=https://kubernetes.default.svc.cluster.local \
  --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \
  --kubelet-client-certificate=/etc/kubernetes/pki/kube-apiserver.pem \
  --kubelet-client-key=/etc/kubernetes/pki/kube-apiserver-key.pem \
  --runtime-config=api/all=true \
  --allow-privileged=true \
  --authorization-mode=Node,RBAC \
  --anonymous-auth=false \
  --audit-log-maxage=30 \
  --audit-log-maxbackup=3 \
  --audit-log-maxsize=100 \
  --audit-log-path=/var/log/kube-apiserver-audit.log \
  --logtostderr=true \
  --log-dir=/var/log/kubernetes \
  --v=2 \
  --enable-bootstrap-token-auth=true \
  --token-auth-file=/etc/kubernetes/token.csv \
  --enable-aggregator-routing=true \
  --enable-admission-plugins=NamespaceLifecycle,LimitRanger,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota,ServiceAccount,DefaultStorageClass

Restart=on-failure
RestartSec=5
Type=notify
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
```

### 6.2.4 分发配置文件

```bash
scp token.csv 10.11.141.11:/etc/kubernetes
scp token.csv 10.11.141.12:/etc/kubernetes
scp token.csv 10.11.141.13:/etc/kubernetes

scp ca*.pem 10.11.141.11:/etc/kubernetes/pki
scp ca*.pem 10.11.141.12:/etc/kubernetes/pki
scp ca*.pem 10.11.141.13:/etc/kubernetes/pki

scp kube-apiserver*.pem 10.11.141.11:/etc/kubernetes/pki
scp kube-apiserver*.pem 10.11.141.12:/etc/kubernetes/pki
scp kube-apiserver*.pem 10.11.141.13:/etc/kubernetes/pki

scp kube-apiserver.service 10.11.141.11:/etc/systemd/system/kube-apiserver.service
scp kube-apiserver.service 10.11.141.12:/etc/systemd/system/kube-apiserver.service
scp kube-apiserver.service 10.11.141.13:/etc/systemd/system/kube-apiserver.service
```

### 6.2.5 启动服务

所有主节点启动 api-server

```bash
systemctl daemon-reload
systemctl enable --now kube-apiserver
systemctl status kube-apiserver
```

## 6.3 部署 kube-controller-manager

### 6.3.1 创建证书请求文件

```bash
cd /root/k8s_install/ssl/
```

```bash
cat > kube-controller-manager-csr.json << "EOF"
{
    "CN": "system:kube-controller-manager",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "hosts": [
    "10.11.141.100",
    "10.11.141.11",
    "10.11.141.12",
    "10.11.141.13",
    "10.10.10.14",
    "10.10.10.15",
    "10.10.10.16",
    "10.10.10.17",
    "10.10.10.18",
    "10.10.10.19"
    ],
    "names": [
      {
        "C": "CN",
        "ST": "Beijing",
        "L": "Beijing",
        "O": "system:kube-controller-manager",
        "OU": "system"
      }
    ]
}
EOF
```

### 6.3.2 生成证书

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager
```

### 6.3.3 创建 kubeconfig 文件

```bash
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.11.141.100:6443 --kubeconfig=kube-controller-manager.kubeconfig

kubectl config set-credentials system:kube-controller-manager --client-certificate=kube-controller-manager.pem --client-key=kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig

kubectl config set-context system:kube-controller-manager --cluster=kubernetes --user=system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig

kubectl config use-context system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig
```

### 6.3.4 创建配置文件

```bash
cat > kube-controller-manager.service << "EOF"
[Unit]
Description=Kubernetes Controller Manager

[Service]
ExecStart=/usr/local/bin/kube-controller-manager \
  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \
  --service-cluster-ip-range=10.96.0.0/16 \
  --cluster-cidr=10.244.0.0/16 \
  --allocate-node-cidrs=true \
  --root-ca-file=/etc/kubernetes/pki/ca.pem \
  --service-account-private-key-file=/etc/kubernetes/pki/ca-key.pem \
  --tls-cert-file=/etc/kubernetes/pki/kube-controller-manager.pem \
  --tls-private-key-file=/etc/kubernetes/pki/kube-controller-manager-key.pem \
  --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \
  --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \
  --feature-gates=RotateKubeletServerCertificate=true \
  --controllers=*,bootstrapsigner,tokencleaner \
  --use-service-account-credentials=true \
  --alsologtostderr=true \
  --logtostderr=true \
  --log-dir=/var/log/kubernetes \
  --v=2
  
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

### 6.3.5 分发配置文件

```bash
scp kube-controller-manager*.pem 10.11.141.11:/etc/kubernetes/pki/
scp kube-controller-manager*.pem 10.11.141.12:/etc/kubernetes/pki/
scp kube-controller-manager*.pem 10.11.141.13:/etc/kubernetes/pki/

scp kube-controller-manager.kubeconfig 10.11.141.11:/etc/kubernetes/
scp kube-controller-manager.kubeconfig 10.11.141.12:/etc/kubernetes/
scp kube-controller-manager.kubeconfig 10.11.141.13:/etc/kubernetes/

scp kube-controller-manager.service 10.11.141.11:/usr/lib/systemd/system/
scp kube-controller-manager.service 10.11.141.12:/usr/lib/systemd/system/
scp kube-controller-manager.service 10.11.141.13:/usr/lib/systemd/system/
```

### 6.3.6 启动服务

所有主节点启动 controller-manager

```bash
systemctl daemon-reload 
systemctl enable --now kube-controller-manager
systemctl status kube-controller-manager
```

## 6.4 部署 kube-scheduler

### 6.4.1 创建证书请求文件

```bash
cd /root/k8s_install/ssl/
```

```bash
cat > kube-scheduler-csr.json << "EOF"
{
    "CN": "system:kube-scheduler",
    "hosts": [
    "10.11.141.100",
    "10.11.141.11",
    "10.11.141.12",
    "10.11.141.13",
    "10.10.10.14",
    "10.10.10.15",
    "10.10.10.16",
    "10.10.10.17",
    "10.10.10.18",
    "10.10.10.19"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
      {
        "C": "CN",
        "ST": "Beijing",
        "L": "Beijing",
        "O": "system:kube-scheduler",
        "OU": "system"
      }
    ]
}
EOF
```

### 6.4.2 生成证书

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler
```

### 6.4.3 创建 kubeconfig 文件

```bash
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.11.141.100:6443 --kubeconfig=kube-scheduler.kubeconfig

kubectl config set-credentials system:kube-scheduler --client-certificate=kube-scheduler.pem --client-key=kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig

kubectl config set-context system:kube-scheduler --cluster=kubernetes --user=system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig

kubectl config use-context system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig
```

### 6.4.4 创建配置文件

```bash
cat > kube-scheduler.service << "EOF"
[Unit]
Description=Kubernetes Scheduler

[Service]
ExecStart=/usr/local/bin/kube-scheduler \
  --kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

### 6.4.5 分发配置文件

```bash
scp kube-scheduler*.pem 10.11.141.11:/etc/kubernetes/pki/
scp kube-scheduler*.pem 10.11.141.12:/etc/kubernetes/pki/
scp kube-scheduler*.pem 10.11.141.13:/etc/kubernetes/pki/

scp kube-scheduler.kubeconfig 10.11.141.11:/etc/kubernetes/
scp kube-scheduler.kubeconfig 10.11.141.12:/etc/kubernetes/
scp kube-scheduler.kubeconfig 10.11.141.13:/etc/kubernetes/

scp kube-scheduler.service 10.11.141.11:/usr/lib/systemd/system/
scp kube-scheduler.service 10.11.141.12:/usr/lib/systemd/system/
scp kube-scheduler.service 10.11.141.13:/usr/lib/systemd/system/
```

### 6.4.6 启动服务

所有主节点启动 scheduler

```bash
systemctl daemon-reload
systemctl enable --now kube-scheduler
systemctl status kube-scheduler
```

## 6.5 部署 kubectl

### 6.5.1 创建证书请求文件

```bash
cd /root/k8s_install/ssl/
```

```bash
cat > admin-csr.json << "EOF"
{
  "CN": "admin",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Beijing",
      "L": "Beijing",
      "O": "system:masters",             
      "OU": "system"
    }
  ]
}
EOF
```

> - 后续 kube-apiserver 使用 RBAC 对客户端（如 kubelet、kube-proxy、Pod) 请求进行授权；
> - kube-apiserver 预定义了一些 RBAC 使用的 RoleBindings，如 cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予了调用 kube-apiserver 的所有 API 的权限；
> - O 指定该证书的 Group 为 system:masters，kubelet 使用该证书访问 kube-apiserver 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 system:masters，所以被授予访问所有 API 的权限；
> - 注：这个 admin 证书，是将来生成管理员用的 kubeconfig 配置文件用的，现在我们一般建议使用 RBAC 来对 kubernetes 进行角色权限控制， kubernetes 将证书中的 CN 字段 作为 User， O 字段作为 Group；
> - "O": "system:masters"，必须是 system:masters，否则后面 kubectl create clusterrolebinding 报错。

### 6.5.2 生成证书文件

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
```

### 6.5.3 复制文件到指定目录

```bash
cp admin*.pem /etc/kubernetes/pki
```

### 6.5.4 生成 kubeconfig 配置文件

kubeconfig.config 为 kubectl 的配置文件，包含访问 apiserver 的所有信息，如 apiserver 地址、CA 证书和自身使用的证书

```bash
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.11.141.100:6443 --kubeconfig=kubeconfig.config

kubectl config set-credentials admin --client-certificate=admin.pem --client-key=admin-key.pem --embed-certs=true --kubeconfig=kubeconfig.config

kubectl config set-context kubernetes --cluster=kubernetes --user=admin --kubeconfig=kubeconfig.config

kubectl config use-context kubernetes --kubeconfig=kubeconfig.config
```

### 6.5.5 准备配置文件并进行角色绑定

```bash
cp kubeconfig.config ~/.kube/config
kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes --kubeconfig=/root/.kube/config
```

### 6.5.6 配置 kubectl 命令补全

```bash
echo "export KUBECONFIG=$HOME/.kube/config" >> ~/.bashrc
echo 'source <(kubectl completion bash)' >> ~/.bashrc
source ~/.bashrc
```

### 6.5.7 分发配置文件

```bash
scp /root/.bashrc 10.11.141.12:/root/.bashrc
scp /root/.bashrc 10.11.141.13:/root/.bashrc
scp /root/.kube/config 10.11.141.12:/root/.kube/config
scp /root/.kube/config 10.11.141.13:/root/.kube/config
```

### 6.5.8 查看集群状态

```bash
# 查看组件状态
$ kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE                         ERROR
controller-manager   Healthy   ok                              
scheduler            Healthy   ok                              
etcd-0               Healthy   {"health":"true","reason":""}   
etcd-1               Healthy   {"health":"true","reason":""}   
etcd-2               Healthy   {"health":"true","reason":""}
```

## 6.6 部署 kubelet

### 6.6.1 创建 kubeconfig 文件

```bash
cd /root/k8s_install/ssl/
```

```bash
BOOTSTRAP_TOKEN=$(awk -F "," '{print $1}' /etc/kubernetes/token.csv)

kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.11.141.100:6443 --kubeconfig=kubelet-bootstrap.kubeconfig

kubectl config set-credentials kubelet-bootstrap --token=${BOOTSTRAP_TOKEN} --kubeconfig=kubelet-bootstrap.kubeconfig

kubectl config set-context default --cluster=kubernetes --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig

kubectl config use-context default --kubeconfig=kubelet-bootstrap.kubeconfig
```

```bash
kubectl create clusterrolebinding cluster-system-anonymous --clusterrole=cluster-admin --user=kubelet-bootstrap

kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap --kubeconfig=kubelet-bootstrap.kubeconfig
```

### 6.6.2 创建配置文件

```bash
cat > kubelet-conf.yml <<EOF
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
address: 0.0.0.0
port: 10250
readOnlyPort: 10255
authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 2m0s
    enabled: true
  x509:
    clientCAFile: /etc/kubernetes/pki/ca.pem
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 5m0s
    cacheUnauthorizedTTL: 30s
cgroupDriver: systemd
cgroupsPerQOS: true
clusterDNS:
- 10.96.0.2
clusterDomain: cluster.local.
containerLogMaxFiles: 5
containerLogMaxSize: 10Mi
contentType: application/vnd.kubernetes.protobuf
cpuCFSQuota: true
cpuManagerPolicy: none
cpuManagerReconcilePeriod: 10s
enableControllerAttachDetach: true
enableDebuggingHandlers: true
enforceNodeAllocatable:
- pods
eventBurst: 10
eventRecordQPS: 5
evictionHard:
  imagefs.available: 15%
  memory.available: 100Mi
  nodefs.available: 10%
  nodefs.inodesFree: 5%
evictionPressureTransitionPeriod: 5m0s
failSwapOn: true
fileCheckFrequency: 20s
hairpinMode: promiscuous-bridge
healthzBindAddress: 127.0.0.1
healthzPort: 10248
httpCheckFrequency: 20s
imageGCHighThresholdPercent: 85
imageGCLowThresholdPercent: 80
imageMinimumGCAge: 2m0s
iptablesDropBit: 15
iptablesMasqueradeBit: 14
kubeAPIBurst: 10
kubeAPIQPS: 5
makeIPTablesUtilChains: true
maxOpenFiles: 1000000
maxPods: 110
nodeStatusUpdateFrequency: 10s
oomScoreAdj: -999
podPidsLimit: -1
registryBurst: 10
registryPullQPS: 5
resolvConf: /etc/resolv.conf
rotateCertificates: true
runtimeRequestTimeout: 2m0s
serializeImagePulls: false
streamingConnectionIdleTimeout: 4h0m0s
syncFrequency: 1m0s
volumeStatsAggPeriod: 1m0s
EOF
```

### 6.6.3 创建服务管理文件

```bash
cat > kubelet.service << "EOF"
[Unit]
Description=Kubernetes Kubelet
After=containerd.service
Requires=containerd.service

[Service]
WorkingDirectory=/var/lib/kubelet
ExecStart=/usr/local/bin/kubelet \
  --bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \
  --cert-dir=/etc/kubernetes/pki \
  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \
  --config=/etc/kubernetes/kubelet-conf.yml \
  --container-runtime=remote \
  --container-runtime-endpoint=unix:///run/containerd/containerd.sock \
  --pod-infra-container-image=proxy.localharbor.com/google_imgs/pause:3.6 \
  --cgroup-driver=systemd \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

### 6.6.4 分发配置文件

```bash
cat > kubelet.sh << 'EOF'
IP="10.11.141.11 10.11.141.12 10.11.141.13 10.11.141.21 10.11.141.22"
for HOST in ${IP[@]}
do 
    scp kubelet-conf.yml $HOST:/etc/kubernetes/
    scp kubelet-bootstrap.kubeconfig $HOST:/etc/kubernetes/
    scp ca.pem $HOST:/etc/kubernetes/pki/
    scp kubelet.service $HOST:/usr/lib/systemd/system/
done 
EOF
```

```bash
bash kubelet.sh
```

### 6.6.5 启动服务

所有集群节点启动 kubelet

```bash
systemctl daemon-reload
systemctl enable --now kubelet.service
systemctl status kubelet
```

## 6.7 部署 kube-proxy

### 6.7.1 创建证书请求文件

```bash
cd /root/k8s_install/ssl/
```

```bash
cat > kube-proxy-csr.json << "EOF"
{
  "CN": "system:kube-proxy",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Beijing",
      "L": "Beijing",
      "O": "digitalchina",
      "OU": "CN"
    }
  ]
}
EOF
```

### 6.7.2 生成证书

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy
```

### 6.7.3 创建 kubeconfig 文件

```bash
kubectl config set-cluster kubernetes --certificate-authority=ca.pem --embed-certs=true --server=https://10.11.141.100:6443 --kubeconfig=kube-proxy.kubeconfig

kubectl config set-credentials kube-proxy --client-certificate=kube-proxy.pem --client-key=kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig

kubectl config set-context default --cluster=kubernetes --user=kube-proxy --kubeconfig=kube-proxy.kubeconfig

kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
```

### 6.7.4 创建配置文件

```bash
cat > kube-proxy.yaml << EOF
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 0.0.0.0
clientConnection:
  acceptContentTypes: ""
  burst: 10
  contentType: application/vnd.kubernetes.protobuf
  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig
  qps: 5
clusterCIDR: 10.244.0.0/16 
configSyncPeriod: 15m0s
conntrack:
  max: null
  maxPerCore: 32768
  min: 131072
  tcpCloseWaitTimeout: 1h0m0s
  tcpEstablishedTimeout: 24h0m0s
enableProfiling: false
healthzBindAddress: 0.0.0.0:10256
hostnameOverride: ""
iptables:
  masqueradeAll: false
  masqueradeBit: 14
  minSyncPeriod: 0s
  syncPeriod: 30s
ipvs:
  masqueradeAll: true
  minSyncPeriod: 5s
  scheduler: "rr"
  syncPeriod: 30s
kind: KubeProxyConfiguration
metricsBindAddress: 0.0.0.0:10249
mode: "ipvs"
nodePortAddresses: null
oomScoreAdj: -999
portRange: ""
udpIdleTimeout: 250ms
EOF
```

### 6.7.5 创建服务管理文件

```bash
cat > kube-proxy.service << "EOF"
[Unit]
Description=Kubernetes Kube-Proxy Server
After=network.target

[Service]
WorkingDirectory=/var/lib/kube-proxy
ExecStart=/usr/local/bin/kube-proxy \
  --config=/etc/kubernetes/kube-proxy.yaml \
  --alsologtostderr=true \
  --logtostderr=false \
  --log-dir=/var/log/kubernetes \
  --v=2
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
```

### 6.7.6 分发配置文件

```bash
cat > proxy.sh << 'EOF'
IP="10.11.141.11 10.11.141.12 10.11.141.13 10.11.141.21 10.11.141.22"
for HOST in ${IP[@]}
do 
    scp kube-proxy.kubeconfig $HOST:/etc/kubernetes/
    scp kube-proxy.yaml $HOST:/etc/kubernetes/
    scp kube-proxy.service $HOST:/usr/lib/systemd/system/
done 
EOF
```

```bash
bash proxy.sh
```

### 6.7.7 服务启动

所有节点启动 kube-proxy

```bash
systemctl daemon-reload
systemctl enable --now kube-proxy
systemctl status kube-proxy
```

## 6.8 部署 Calico

### 6.8.1 部署文件

```bash
cd /root/k8s_install/soft/
```

### 6.8.2 修改配置文件

镜像仓库地址

```bash
wget --no-check-certificate https://docs.projectcalico.org/v3.19/manifests/calico.yaml -O calico.yaml
```

```bash
sed -i 's#docker.io/calico#proxy.localharbor.com/google_imgs#g' calico.yaml
```

pod 网段

```bash
3683             - name: CALICO_IPV4POOL_CIDR
3684               value: "10.244.0.0/16"
```

### 6.8.3 部署 Calico

```bash
kubectl apply -f calico.yaml
```

查看运行状态

```bash
$ kubectl get pods -A
NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE
kube-system   calico-kube-controllers-5b7cd75dcb-sv728   1/1     Running   0          23s
kube-system   calico-node-686pz                          1/1     Running   0          23s
kube-system   calico-node-bbtps                          1/1     Running   0          23s
kube-system   calico-node-bj69m                          1/1     Running   0          23s
kube-system   calico-node-k2kb4                          1/1     Running   0          23s
kube-system   calico-node-z8dxv                          1/1     Running   0          23s
```

## 6.9 部署 CoreDNS

### 6.9.1 部署文件

```bash
cat > coredns.yaml << "EOF"
apiVersion: v1
kind: ServiceAccount
metadata:
  name: coredns
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:coredns
rules:
  - apiGroups:
    - ""
    resources:
    - endpoints
    - services
    - pods
    - namespaces
    verbs:
    - list
    - watch
  - apiGroups:
    - discovery.k8s.io
    resources:
    - endpointslices
    verbs:
    - list
    - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:coredns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:coredns
subjects:
- kind: ServiceAccount
  name: coredns
  namespace: kube-system
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    .:53 {
        errors
        health {
          lameduck 5s
        }
        ready
        kubernetes cluster.local  in-addr.arpa ip6.arpa {
          fallthrough in-addr.arpa ip6.arpa
        }
        prometheus :9153
        forward . /etc/resolv.conf {
          max_concurrent 1000
        }
        cache 30
        loop
        reload
        loadbalance
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coredns
  namespace: kube-system
  labels:
    k8s-app: kube-dns
    kubernetes.io/name: "CoreDNS"
spec:
  # replicas: not specified here:
  # 1. Default is 1.
  # 2. Will be tuned in real time if DNS horizontal auto-scaling is turned on.
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  selector:
    matchLabels:
      k8s-app: kube-dns
  template:
    metadata:
      labels:
        k8s-app: kube-dns
    spec:
      priorityClassName: system-cluster-critical
      serviceAccountName: coredns
      tolerations:
        - key: "CriticalAddonsOnly"
          operator: "Exists"
      nodeSelector:
        kubernetes.io/os: linux
      affinity:
         podAntiAffinity:
           preferredDuringSchedulingIgnoredDuringExecution:
           - weight: 100
             podAffinityTerm:
               labelSelector:
                 matchExpressions:
                   - key: k8s-app
                     operator: In
                     values: ["kube-dns"]
               topologyKey: kubernetes.io/hostname
      containers:
      - name: coredns
        image: proxy.localharbor.com/google_imgs/coredns:1.8.4
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: 170Mi
          requests:
            cpu: 100m
            memory: 70Mi
        args: [ "-conf", "/etc/coredns/Corefile" ]
        volumeMounts:
        - name: config-volume
          mountPath: /etc/coredns
          readOnly: true
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 9153
          name: metrics
          protocol: TCP
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - all
          readOnlyRootFilesystem: true
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 5
        readinessProbe:
          httpGet:
            path: /ready
            port: 8181
            scheme: HTTP
      dnsPolicy: Default
      volumes:
        - name: config-volume
          configMap:
            name: coredns
            items:
            - key: Corefile
              path: Corefile
---
apiVersion: v1
kind: Service
metadata:
  name: kube-dns
  namespace: kube-system
  annotations:
    prometheus.io/port: "9153"
    prometheus.io/scrape: "true"
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: "CoreDNS"
spec:
  selector:
    k8s-app: kube-dns
  clusterIP: 10.96.0.2
  ports:
  - name: dns
    port: 53
    protocol: UDP
  - name: dns-tcp
    port: 53
    protocol: TCP
  - name: metrics
    port: 9153
    protocol: TCP
 
EOF
```

### 6.9.2 部署 CoreDNS

```bash
kubectl apply -f coredns.yaml
```

```bash
$ kubectl get pod -A
NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE
kube-system   calico-kube-controllers-5b7cd75dcb-sv728   1/1     Running   0          119s
kube-system   calico-node-686pz                          1/1     Running   0          119s
kube-system   calico-node-bbtps                          1/1     Running   0          119s
kube-system   calico-node-bj69m                          1/1     Running   0          119s
kube-system   calico-node-k2kb4                          1/1     Running   0          119s
kube-system   calico-node-z8dxv                          1/1     Running   0          119s
kube-system   coredns-7bb6c9464b-pcmcs                   1/1     Running   0          51s
```

# 七、查看集群状态

```bash
$ kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE                         ERROR
scheduler            Healthy   ok                              
controller-manager   Healthy   ok                              
etcd-0               Healthy   {"health":"true","reason":""}   
etcd-1               Healthy   {"health":"true","reason":""}   
etcd-2               Healthy   {"health":"true","reason":""}
```

```bash
$ kubectl get node -o wide
NAME       STATUS   ROLES    AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME
master01   Ready    <none>   9m39s   v1.23.8   10.11.141.11   <none>        CentOS Linux 7 (Core)   5.18.14-1.el7.elrepo.x86_64   containerd://1.6.6
master02   Ready    <none>   9m39s   v1.23.8   10.11.141.12   <none>        CentOS Linux 7 (Core)   5.18.14-1.el7.elrepo.x86_64   containerd://1.6.6
master03   Ready    <none>   9m39s   v1.23.8   10.11.141.13   <none>        CentOS Linux 7 (Core)   5.18.14-1.el7.elrepo.x86_64   containerd://1.6.6
worker01   Ready    <none>   9m39s   v1.23.8   10.11.141.21   <none>        CentOS Linux 7 (Core)   5.18.14-1.el7.elrepo.x86_64   containerd://1.6.6
worker02   Ready    <none>   9m39s   v1.23.8   10.11.141.22   <none>        CentOS Linux 7 (Core)   5.18.14-1.el7.elrepo.x86_64   containerd://1.6.6
```

